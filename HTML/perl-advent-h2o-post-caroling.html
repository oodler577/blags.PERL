During the 2022 <a href=https://perladvent.org/2022/2022-12-06.html target=_other>Perl Advent</a>,
in particular the entry for <a href=https://perladvent.org/2022/2022-12-06.html>December 06</a>; we
were introduced to a module called <pre>Util::H2O</pre>.

<p/>
<p/>

A lot has already been said about <pre>Util::H2O</pre>, and this author (Oodler, Mayor of
<i>Flavortown</i>) uses it a lot in client and production code. So much so, that he created the
<pre>Util::H2O::More</pre> module to encapsulate some common tasks and additional capabilities
for working between <i>pure</i> Perl data structures and <i>blessed</i> objects that have real
data <i>accessors</i>.

<p/>
<p/>

As a result of the Perl Advent post, another need was revealed. The original intent of <pre>h2o</pre>
was only to take a purely <pre>HASH</pre> reference based data structure, and with this intent it
shall return (as it should). And even though <pre>h2o</pre> supports the <pre>-recurse</pre> option;
it refuses to enter into anything but a <pre>HASH</pre> ref. That means if it encounters the other
legitimate container reference, <pre>HTML</pre>. This restriction applies similarly to <pre>o2h</pre>,
the inverse (or <i>undoer</i>) of <pre>h2o</pre>.

<p/>
<p/>

A new <i>keyword</i> (because this is how they should be viewed) was introduced in <pre>Util::H2O::More</pre>,
called <pre>d2o</pre> and it's <i>undoer</i>, <pre>o2d</pre>. Essentially, it traverses
a Perl data structure, looking for pure <pre>HASH</pre> refs that may be potentially contained inside of
<pre>ARRAY</pre> refs.

<p/>
<p/>

Below is the <pre>JSON</pre> from the Perl Advent entry on December 06, 2022. In this entry, <pre>h2o</pre>
was used to <i>objectify</i> each individual user record since when <i>decoded</i> from the <pre>JSON</pre>,
it became a <pre>HASH</pre> ref. Because <pre>h2o</pre> only works with data structures that contain purely
<pre>HASH</pre> references, an explicit iteration step had to be introduced to apply <pre>h2o</pre>
to each <pre>HASH</pre> ref. That is,

<p/>
<p/>

<pre>
# decode JSON from response content
my $json_array_ref = JSON::decode_json($response->content); # $json is an ARRAY reference

foreach my $person (@$json_array_ref) {

    # -recurse creates deep accessors, e.g.,
    #  $person->address->geo->lat;

    h2o -recurse, $person;

    ...

}
</pre> 

<p/>
Was used to <i>objectify</i> each record contained in <pre>JSON</pre> of the form,
<p/>

<pre>
[
  {
    "id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "Sincere@april.biz",
    "address": {
      "street": "Kulas Light",
      "suite": "Apt. 556",
      "city": "Gwenborough",
      "zipcode": "92998-3874",
      "geo": {
        "lat": "-37.3159",
        "lng": "81.1496"
      }
    }
  },
 ...
]
</pre>

<p/>

The problem revealed here is that <pre>h2o</pre> is amazing for giving accessors those
ad hoc or temporary <i>pure</i> <pre>HASH</pre> references all Perl programmers come to know
and love. But the veil gets pierced once an <pre>ARRAY</pre> ref is encountered. And this
is what happens in the example above.

<p/>

How should this be solved? By generalizing <pre>h2o</pre> into a <i>keyword</i> that has
the ability to traverse any Perl data structure, adding accessors to any <pre>HASH</pre> ref
it finds along this way. This is what <pre>d2o</pre> does. 

<p/>

Now the explicit iteration that is just for adding accessors to each record, goes from a loop
having to dereference the <pre>ARRAY<pre> ref in <pre>$json_array_ref</pre>, to the following:

<p/>

<pre>
# decode JSON from response content
my $json_array_ref = d2o JSON::decode_json($response->content); # $json is an ARRAY reference
</pre>

<p/>

<pre>d2o</pre> doesn't just ignore <pre>ARRAYs</pre>, it goes a step further by providing
<i>virtual</i> methods around the <pre>ARRAY</pre> container that further helps avoid the need
to use <pre>ARRAY</pre>dereferencing syntax to iterate over the <pre>HASH</pre> references
(now blessed with accessors). See the example below,

<p/>

<pre>
foreach my $user ($json_array_ref->all) {
  printf qq{%5.4f, %5.4f, %s, %s\n},
    $person->address->geo->lat,   # deep chain of accessors from '-recurse'
    $person->address->geo->lng,   # deep chain of accessors from '-recurse'
    $person->name,
    $person->username;  
}
</pre>

<p/>

Or more concisely,

<p/>

<pre>
use strict;
use warnings;
use Util::H2O::More qw/d2o/;

my $http     = HTTP::Tiny->new;
my $response = h2o $http->get(q{https://jsonplaceholder.typicode.com/users});

# decode JSON from response content
my $json_array_ref = d2o JSON::decode_json( $response->content );    # $json is an ARRAY reference

foreach my $user ( $json_array_ref->all ) {
    printf qq{%5.4f, %5.4f, %s, %s\n}, $person->address->geo->lat, $person->address->geo->lng, $person->name, $person->username;
}
</pre>
<p/>
